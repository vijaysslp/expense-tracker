<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Expense Analyzer (Gmail)</title>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, Arial; max-width:1100px; margin: 24px auto; padding: 12px; }
    header { display:flex; gap:12px; align-items:center; margin-bottom:16px;}
    button { padding:8px 12px; border-radius:6px; border:1px solid #ddd; background:#f6f6f6; cursor:pointer }
    .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; margin-bottom:16px; }
    .card { padding:12px; border:1px solid #eee; border-radius:8px; background:white; box-shadow:0 1px 3px rgba(0,0,0,.03)}
    pre { background:#f8f8f8; padding:8px; border-radius:6px; overflow:auto; }
    table { width:100%; border-collapse:collapse }
    th,td { padding:6px 8px; border-bottom:1px solid #eee; text-align:left }
  </style>
</head>
<body>
  <header>
    <h1>Expense Analyzer (Gmail)</h1>
    <div style="margin-left:auto">
      <button id="connectBtn">Connect Gmail</button>
      <button id="scanBtn" disabled>Scan Gmail</button>
      <button id="exportCsvBtn" disabled>Export CSV</button>
      <button id="backupBtn" disabled>Export Backup</button>
    </div>
  </header>

  <section class="grid">
    <div class="card">
      <h3>Total Expenses</h3>
      <div id="totalAmt">—</div>
      <div id="txCount">— transactions</div>
    </div>
    <div class="card">
      <h3>By Card</h3>
      <div id="byCard">—</div>
    </div>
    <div class="card">
      <h3>Upcoming Bills</h3>
      <div id="upcoming">—</div>
    </div>
  </section>

  <section class="card">
    <h3>Transactions (latest 200 scanned)</h3>
    <table id="txTable">
      <thead><tr><th>Date</th><th>Amount</th><th>Merchant</th><th>Card</th><th>Source</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <section style="margin-top:12px" class="card">
    <h3>Notes & Actions</h3>
    <p>After scanning, click any upcoming bill to generate a calendar reminder (.ics) for 1 week / 3 days / 2 days / day-of.</p>
    <pre id="log"></pre>
  </section>

<script type="module">
/*
  Simple Gmail expense scanner — client-only.
  Requirements: create OAuth Client ID for Web and paste below.
*/
const CLIENT_ID = "263109576837-3iphn0jaf34739hdltpoaeccjlmf1p4j.apps.googleusercontent.com"; // <<--- REPLACE
const SCOPES = "https://www.googleapis.com/auth/gmail.readonly";

let tokenClient; 
let accessToken = null;

const connectBtn = document.getElementById("connectBtn");
const scanBtn = document.getElementById("scanBtn");
const exportCsvBtn = document.getElementById("exportCsvBtn");
const backupBtn = document.getElementById("backupBtn");
const logEl = document.getElementById("log");

const state = {
  emailsScanned: 0,
  transactions: [], // {amount, merchant, date, messageId, card, raw}
  cards: {}, // cardId -> {limit(optional), used}
};

function log(s){ console.log(s); logEl.textContent = (new Date()).toISOString()+" — "+s+"\n"+logEl.textContent }

function onGsiLoad() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: (resp) => {
      if (resp.error) {
        log("Auth error: "+JSON.stringify(resp));
        return;
      }
      accessToken = resp.access_token;
      log("Got access token");
      scanBtn.disabled = false; exportCsvBtn.disabled=false; backupBtn.disabled=false;
    }
  });
}

window.onload = () => {
  onGsiLoad();
};

connectBtn.addEventListener("click", async () => {
  tokenClient.requestAccessToken();
});

// helper to call Gmail REST
async function gmailFetch(path, params = {}) {
  const url = new URL(`https://gmail.googleapis.com/gmail/v1/${path}`);
  Object.keys(params).forEach(k => url.searchParams.set(k, params[k]));
  log("Gmail fetch: " + url.toString());
  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  if (!r.ok) {
    const text = await r.text();
    throw new Error("Gmail API error: "+r.status+" "+text);
  }
  return r.json();
}

// main flow: search messages, fetch content, parse for transactions
scanBtn.addEventListener("click", async () => {
  if (!accessToken) { log("Please connect first"); return; }
  log("Starting scan (this may take a few moments)...");
  state.transactions = [];
  try {
    // query targeting receipts/transactions — tweak as needed
    // this uses Gmail search language — looks for receipts/transaction/bank words
    const q = "subject:(receipt OR transaction OR debited OR credited OR payment OR spent) OR from:(@icicibank @hdfcbank @axisbank @sbi @paytm @razorpay OR noreply@)";

    // list messages (max 500 in pages)
    let nextPageToken = null;
    let totalFetched = 0;
    const pageLimit = 200; // limit to keep UI responsive
    do {
      const res = await gmailFetch("users/me/messages", {
        q: q,
        maxResults: 100,
        pageToken: nextPageToken || ""
      });
      nextPageToken = res.nextPageToken;
      const msgs = res.messages || [];
      for (const m of msgs) {
        if (totalFetched >= pageLimit) break;
        const full = await gmailFetch(`users/me/messages/${m.id}`, { format: "full" });
        totalFetched++;
        await processMessage(full);
      }
    } while (nextPageToken && totalFetched < pageLimit);

    log(`Scan complete: processed ${totalFetched} messages, found ${state.transactions.length} transactions.`);
    renderDashboard();
  } catch (e) {
    log("Scan failed: " + (e.message || e));
    console.error(e);
  }
});

// turn Gmail message payload to plain text
function getMessageBody(message) {
  try {
    // search payload parts for text/plain or just snippet
    if (message.payload && message.payload.parts) {
      for (const p of message.payload.parts) {
        if (p.mimeType === "text/plain" && p.body && p.body.data) {
          return decodeBase64Url(p.body.data);
        }
      }
    }
    // fallback to snippet
    if (message.snippet) return message.snippet;
  } catch (e) {}
  return "";
}

function decodeBase64Url(b64) {
  // Gmail uses base64url without padding
  b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
  while (b64.length % 4) b64 += '=';
  try { return decodeURIComponent(escape(atob(b64))); } catch(e) { return atob(b64); }
}

// simple parser heuristics
function parseTransactionFromText(text) {
  if (!text) return null;
  // quick detection: must contain currency indicator or "spent"/"debited"
  if (!/(INR|Rs\.?|₹|spent|debited|transaction|payment)/i.test(text)) return null;

  // amount regex
  const amtMatch = text.match(/(?:INR|Rs\.?|₹)\s*([0-9,]+(?:\.[0-9]{1,2})?)/i)
    || text.match(/([0-9,]+\.[0-9]{2})\s*(?:INR|Rs\.?|₹)?/i);
  const amount = amtMatch ? parseFloat(amtMatch[1].replace(/,/g,'')) : null;

  // merchant heuristics
  const merchantMatch = text.match(/(?:at|to|via|merchant[:\s])\s*([A-Z0-9 &._-]{2,60})/i)
    || text.match(/(?:from|merchant)\s*[:\-]\s*([A-Z0-9 &._-]{2,60})/i);
  const merchant = merchantMatch ? merchantMatch[1].trim().replace(/\s+/g,' ') : null;

  // card detection (card ending / VISA / MASTERCARD)
  let card = null;
  const cardMatch = text.match(/(card(?:\s*ending)?\s*[:\s]?(\d{2,4}[-\d]*\d{2,4})|VISA|MASTERCARD|MASTER|AMEX|AMERICAN EXPRESS|DISCOVER)/i);
  if (cardMatch) card = (cardMatch[2] || cardMatch[1]).toString();

  // date heuristics
  const dateMatch = text.match(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/) || text.match(/(20\d{2}-\d{2}-\d{2})/);
  const when = dateMatch ? new Date(dateMatch[1]).getTime() : Date.now();

  if (!amount) return null; // can't parse amount -> not a transaction

  return {
    amount,
    merchant,
    when,
    card,
  };
}

async function processMessage(msg) {
  const body = getMessageBody(msg);
  const parsed = parseTransactionFromText(body + "\n" + (msg.snippet||"") + "\n" + (msg.payload?.headers?.map(h=>h.name+':'+h.value).join('\n')||''));
  if (parsed) {
    const tx = {
      amount: parsed.amount,
      amountPaise: Math.round(parsed.amount * 100),
      merchant: parsed.merchant,
      date: parsed.when || Date.now(),
      card: parsed.card || detectCardFromHeaders(msg.payload?.headers),
      messageId: msg.id,
      snippet: msg.snippet,
      raw: body,
      source: 'gmail'
    };
    state.transactions.push(tx);
  }
  state.emailsScanned++;
}

// look for X- headers or 'card' phrases in headers
function detectCardFromHeaders(headers) {
  if (!headers) return null;
  const hstr = headers.map(h=>`${h.name}:${h.value}`).join('\n');
  const m = hstr.match(/(Visa|Mastercard|MasterCard|Amex|American Express|Discover|Rupay|RuPay)/i);
  if (m) return m[1];
  const cardNo = hstr.match(/card(?:\s*ending)?\s*[:\s]?(\d{2,4}[-\d]*\d{2,4})/i);
  return cardNo ? cardNo[1] : null;
}

function renderDashboard() {
  // totals
  const total = state.transactions.reduce((s,t)=>s + (t.amount || 0), 0);
  document.getElementById("totalAmt").textContent = `₹ ${total.toFixed(2)}`;
  document.getElementById("txCount").textContent = `${state.transactions.length} transactions`;

  // by card
  const byCard = {};
  state.transactions.forEach(t => {
    const k = t.card || "Unknown";
    byCard[k] = byCard[k] || {count:0, sum:0};
    byCard[k].count++;
    byCard[k].sum += t.amount;
  });
  const byCardEl = document.getElementById("byCard");
  byCardEl.innerHTML = Object.entries(byCard).map(([k,v]) => `<div>${k}: ${v.count} tx • ₹${v.sum.toFixed(2)}</div>`).join('');

  // upcoming bills detection (very heuristic: look for "due" "statement" and date)
  const upcoming = state.transactions.filter(t => /due|statement|minimum due|payment due/i.test(t.raw||t.snippet||''));
  const upcomingEl = document.getElementById("upcoming");
  upcomingEl.innerHTML = upcoming.length ? upcoming.slice(0,5).map((u,i) => {
    const d = new Date(u.date);
    return `<div style="cursor:pointer" onclick="createIcs(${u.date}, ${u.amountPaise}, '${escapeHtml(u.merchant||'Unknown')}')">• ${u.merchant||'Unknown'} — ₹${(u.amount).toFixed(2)} — ${d.toLocaleDateString()}</div>`;
  }).join('') : "No obvious upcoming bills found";

  // table
  const tbody = document.querySelector("#txTable tbody");
  tbody.innerHTML = state.transactions.map(t => `<tr>
    <td>${new Date(t.date).toLocaleString()}</td>
    <td>₹${t.amount.toFixed(2)}</td>
    <td>${escapeHtml(t.merchant||'Unknown')}</td>
    <td>${escapeHtml(t.card||'Unknown')}</td>
    <td>${escapeHtml(t.source)}</td>
  </tr>`).join('');
}

// utility
function escapeHtml(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

// Export CSV
exportCsvBtn.addEventListener("click", () => {
  if (!state.transactions.length) return alert("No transactions");
  const rows = [["date","amount","merchant","card","source"]];
  state.transactions.forEach(t => rows.push([ new Date(t.date).toISOString(), t.amount.toFixed(2), t.merchant||'', t.card||'', t.source]));
  const csv = rows.map(r=>r.map(c=>`"${(c||'').toString().replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href=url; a.download = "expenses.csv"; a.click();
  URL.revokeObjectURL(url);
});

// Backup (basic JSON)
backupBtn.addEventListener("click", () => {
  const data = { exportedAt: new Date().toISOString(), transactions: state.transactions };
  const blob = new Blob([JSON.stringify(data)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href=url; a.download = "expenses-backup.json"; a.click();
  URL.revokeObjectURL(url);
});

// Create ICS for a given date (millis)
window.createIcs = (whenMillis, amountPaise, merchantEsc) => {
  const when = new Date(whenMillis);
  // create reminder events for 7d, 3d, 2d, 0d prior (you can prompt)
  const deltas = [7,3,2,0];
  deltas.forEach(delta => {
    const dt = new Date(whenMillis - delta*24*60*60*1000);
    const dtStr = dt.toISOString().replace(/[-:]/g,'').split('.')[0] + 'Z';
    const uid = 'exp-'+whenMillis+'-'+delta+'@local';
    const summary = `Pay ${merchantEsc} — ₹${(amountPaise/100).toFixed(2)} (due ${when.toLocaleDateString()})`;
    const ics = [
      'BEGIN:VCALENDAR',
      'VERSION:2.0',
      'PRODID:-//ExpenseAnalyzer//EN',
      'BEGIN:VEVENT',
      `UID:${uid}`,
      `DTSTAMP:${new Date().toISOString().replace(/[-:]/g,'').split('.')[0]}Z`,
      `DTSTART:${dtStr}`,
      `SUMMARY:${summary}`,
      `DESCRIPTION:Auto-generated reminder`,
      'END:VEVENT',
      'END:VCALENDAR'
    ].join('\r\n');
    const blob = new Blob([ics], {type:'text/calendar'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download = `reminder-${uid}.ics`; a.click();
    URL.revokeObjectURL(url);
  });
  alert("Downloaded .ics reminders for that bill. Import to your calendar.");
}

</script>
</body>
</html>
